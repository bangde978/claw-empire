import path from "node:path";
import { randomUUID } from "node:crypto";
import type { Lang } from "../../../../types/lang.ts";
import { resolveWorkflowPackKeyForTask } from "../../../workflow/packs/task-pack-resolver.ts";
import type { AgentRow } from "./types.ts";

interface CrossDeptContext {
  teamLeader: AgentRow;
  taskTitle: string;
  ceoMessage: string;
  leaderDeptId: string;
  leaderDeptName: string;
  leaderName: string;
  lang: Lang;
  taskId: string;
  projectId?: string | null;
  projectCandidateAgentIds?: string[] | null;
}
type CrossDeptCooperationDeps = any;

export function createCrossDeptCooperationTools(deps: CrossDeptCooperationDeps) {
  const {
    db,
    nowMs,
    appendTaskLog,
    broadcast,
    recordTaskCreationAudit,
    delegatedTaskToSubtask,
    crossDeptNextCallbacks,
    findTeamLeader,
    findBestSubordinate,
    resolveLang,
    getDeptName,
    getAgentDisplayName,
    sendAgentMessage,
    notifyCeo,
    l,
    pickL,
    startTaskExecutionForAgent,
    linkCrossDeptTaskToParentSubtask,
    detectProjectPath,
    resolveProjectPath,
    logsDir,
    getDeptRoleConstraint,
    getRecentConversationContext,
    buildAvailableSkillsPromptBlock,
    buildTaskExecutionPrompt,
    hasExplicitWarningFixRequest,
    ensureTaskExecutionSession,
    getProviderModelConfig,
    spawnCliAgent,
    handleSubtaskDelegationComplete,
    handleTaskRunComplete,
    startProgressTimer,
  } = deps;

  function getProjectCandidateAgentIds(projectId: string | null | undefined): string[] | null {
    const normalizedProjectId = typeof projectId === "string" ? projectId.trim() : "";
    if (!normalizedProjectId) return null;

    const project = db.prepare("SELECT assignment_mode FROM projects WHERE id = ?").get(normalizedProjectId) as
      | { assignment_mode?: string }
      | undefined;
    if (project?.assignment_mode !== "manual") return null;

    return (
      db.prepare("SELECT agent_id FROM project_agents WHERE project_id = ?").all(normalizedProjectId) as Array<{
        agent_id: string;
      }>
    ).map((row) => row.agent_id);
  }

  function pickManualPoolAgent(
    candidateAgentIds: string[],
    preferredDeptId?: string | null,
    excludeIds: string[] = [],
  ): AgentRow | null {
    const candidateIds = [
      ...new Set(candidateAgentIds.map((id) => String(id || "").trim()).filter((id) => id.length > 0)),
    ];
    if (candidateIds.length === 0) return null;

    const excludedIds = [...new Set(excludeIds.map((id) => String(id || "").trim()).filter((id) => id.length > 0))];
    const idPlaceholders = candidateIds.map(() => "?").join(",");
    const params: unknown[] = [...candidateIds];

    const deptClause = preferredDeptId ? "AND department_id = ?" : "";
    if (preferredDeptId) params.push(preferredDeptId);

    const excludeClause = excludedIds.length > 0 ? `AND id NOT IN (${excludedIds.map(() => "?").join(",")})` : "";
    if (excludedIds.length > 0) params.push(...excludedIds);

    const agents = db
      .prepare(
        `SELECT * FROM agents WHERE id IN (${idPlaceholders}) ${deptClause} ${excludeClause} ORDER BY
         CASE status WHEN 'idle' THEN 0 WHEN 'break' THEN 1 WHEN 'working' THEN 2 ELSE 3 END,
         CASE role WHEN 'senior' THEN 0 WHEN 'junior' THEN 1 WHEN 'intern' THEN 2 WHEN 'team_leader' THEN 3 ELSE 4 END`,
      )
      .all(...params) as unknown as AgentRow[];
    return agents[0] ?? null;
  }

  function recoverCrossDeptQueueAfterMissingCallback(completedChildTaskId: string): void {
    const child = db.prepare("SELECT source_task_id FROM tasks WHERE id = ?").get(completedChildTaskId) as
      | { source_task_id: string | null }
      | undefined;
    if (!child?.source_task_id) return;

    const parent = db
      .prepare(
        `
    SELECT id, title, description, department_id, project_id, status, assigned_agent_id, started_at
    FROM tasks
    WHERE id = ?
  `,
      )
      .get(child.source_task_id) as
      | {
          id: string;
          title: string;
          description: string | null;
          department_id: string | null;
          project_id: string | null;
          status: string;
          assigned_agent_id: string | null;
          started_at: number | null;
        }
      | undefined;
    if (!parent || parent.status !== "collaborating" || !parent.department_id) return;

    const activeSibling = db
      .prepare(
        `
    SELECT 1
    FROM tasks
    WHERE source_task_id = ?
      AND status IN ('planned', 'pending', 'collaborating', 'in_progress', 'review')
    LIMIT 1
  `,
      )
      .get(parent.id);
    if (activeSibling) return;

    const targetDeptRows = db
      .prepare(
        `
    SELECT target_department_id
    FROM subtasks
    WHERE task_id = ?
      AND target_department_id IS NOT NULL
    ORDER BY created_at ASC
  `,
      )
      .all(parent.id) as Array<{ target_department_id: string | null }>;
    const deptIds: string[] = [];
    const seen = new Set<string>();
    for (const row of targetDeptRows) {
      if (!row.target_department_id || seen.has(row.target_department_id)) continue;
      seen.add(row.target_department_id);
      deptIds.push(row.target_department_id);
    }
    if (deptIds.length === 0) return;

    const doneRows = db
      .prepare(
        `
    SELECT department_id
    FROM tasks
    WHERE source_task_id = ?
      AND status = 'done'
      AND department_id IS NOT NULL
  `,
      )
      .all(parent.id) as Array<{ department_id: string | null }>;
    const doneDept = new Set(doneRows.map((r) => r.department_id).filter((v): v is string => !!v));
    const nextIndex = deptIds.findIndex((deptId) => !doneDept.has(deptId));

    const leader = findTeamLeader(parent.department_id);
    if (!leader) return;
    const lang = resolveLang(parent.description ?? parent.title);
    const projectCandidateAgentIds = getProjectCandidateAgentIds(parent.project_id);

    const delegateMainTask = () => {
      const current = db
        .prepare("SELECT status, assigned_agent_id, started_at FROM tasks WHERE id = ?")
        .get(parent.id) as { status: string; assigned_agent_id: string | null; started_at: number | null } | undefined;
      if (!current || current.status !== "collaborating") return;
      if (current.assigned_agent_id || current.started_at) return;

      const subordinate = findBestSubordinate(parent.department_id!, leader.id, projectCandidateAgentIds);
      const manualPoolFallback =
        Array.isArray(projectCandidateAgentIds) && projectCandidateAgentIds.length > 0
          ? pickManualPoolAgent(projectCandidateAgentIds, parent.department_id, [leader.id]) ||
            pickManualPoolAgent(projectCandidateAgentIds, null, [leader.id])
          : null;
      const leaderAllowed = !Array.isArray(projectCandidateAgentIds) || projectCandidateAgentIds.includes(leader.id);
      const assignee = subordinate ?? (leaderAllowed ? leader : manualPoolFallback) ?? leader;
      const deptName = getDeptName(parent.department_id!);
      const t = nowMs();
      db.prepare("UPDATE tasks SET assigned_agent_id = ?, status = 'planned', updated_at = ? WHERE id = ?").run(
        assignee.id,
        t,
        parent.id,
      );
      db.prepare("UPDATE agents SET current_task_id = ? WHERE id = ?").run(parent.id, assignee.id);
      appendTaskLog(
        parent.id,
        "system",
        `Recovery: cross-dept queue completed, delegated to ${assignee.name_ko || assignee.name}`,
      );
      broadcast("task_update", db.prepare("SELECT * FROM tasks WHERE id = ?").get(parent.id));
      broadcast("agent_status", db.prepare("SELECT * FROM agents WHERE id = ?").get(assignee.id));
      startTaskExecutionForAgent(parent.id, assignee, parent.department_id, deptName);
    };

    if (nextIndex === -1) {
      delegateMainTask();
      return;
    }

    const ctx: CrossDeptContext = {
      teamLeader: leader,
      taskTitle: parent.title,
      ceoMessage: (parent.description ?? "").replace(/^\[CEO\]\s*/, ""),
      leaderDeptId: parent.department_id,
      leaderDeptName: getDeptName(parent.department_id),
      leaderName: getAgentDisplayName(leader, lang),
      lang,
      taskId: parent.id,
      projectId: parent.project_id,
      projectCandidateAgentIds,
    };
    const shouldResumeMainAfterAll = !parent.assigned_agent_id && !parent.started_at;
    startCrossDeptCooperation(deptIds, nextIndex, ctx, shouldResumeMainAfterAll ? delegateMainTask : undefined);
  }

  function startCrossDeptCooperation(
    deptIds: string[],
    index: number,
    ctx: CrossDeptContext,
    onAllDone?: () => void,
  ): void {
    if (index >= deptIds.length) {
      onAllDone?.();
      return;
    }

    const crossDeptId = deptIds[index];
    const crossLeader = findTeamLeader(crossDeptId);
    if (!crossLeader) {
      // Skip this dept, try next
      startCrossDeptCooperation(deptIds, index + 1, ctx, onAllDone);
      return;
    }

    const { teamLeader, taskTitle, ceoMessage, leaderDeptId, leaderDeptName, leaderName, lang, taskId } = ctx;
    const resolvedProjectId =
      ctx.projectId ??
      (db.prepare("SELECT project_id FROM tasks WHERE id = ?").get(taskId) as { project_id: string | null } | undefined)
        ?.project_id ??
      null;
    const projectCandidateAgentIds =
      ctx.projectCandidateAgentIds !== undefined
        ? ctx.projectCandidateAgentIds
        : getProjectCandidateAgentIds(resolvedProjectId);
    const nextCtx: CrossDeptContext =
      ctx.projectId === resolvedProjectId && ctx.projectCandidateAgentIds === projectCandidateAgentIds
        ? ctx
        : {
            ...ctx,
            projectId: resolvedProjectId,
            projectCandidateAgentIds,
          };

    const crossDeptName = getDeptName(crossDeptId);
    const manualScoped = Array.isArray(projectCandidateAgentIds);
    const crossSub = manualScoped
      ? findBestSubordinate(crossDeptId, crossLeader.id, projectCandidateAgentIds)
      : findBestSubordinate(crossDeptId, crossLeader.id);
    const crossLeaderAllowed = !manualScoped || projectCandidateAgentIds.includes(crossLeader.id);
    const manualPoolFallback =
      manualScoped && projectCandidateAgentIds.length > 0
        ? pickManualPoolAgent(projectCandidateAgentIds, crossDeptId, [teamLeader.id]) ||
          pickManualPoolAgent(projectCandidateAgentIds, null, [teamLeader.id]) ||
          pickManualPoolAgent(projectCandidateAgentIds, crossDeptId) ||
          pickManualPoolAgent(projectCandidateAgentIds, null)
        : null;
    const crossCoordinator = crossLeaderAllowed ? crossLeader : (crossSub ?? manualPoolFallback ?? crossLeader);
    const crossCoordinatorName =
      lang === "ko" ? crossCoordinator.name_ko || crossCoordinator.name : crossCoordinator.name;

    // Notify remaining queue
    if (deptIds.length > 1) {
      const remaining = deptIds.length - index;
      notifyCeo(
        pickL(
          l(
            [`í˜‘ì—… ìš”ì²­ ì§„í–‰ ì¤‘: ${crossDeptName} (${index + 1}/${deptIds.length}, ë‚¨ì€ ${remaining}íŒ€ ìˆœì°¨ ì§„í–‰)`],
            [
              `Collaboration request in progress: ${crossDeptName} (${index + 1}/${deptIds.length}, ${remaining} team(s) remaining in queue)`,
            ],
            [`å”æ¥­ä¾é ¼é€²è¡Œä¸­: ${crossDeptName} (${index + 1}/${deptIds.length}ã€æ®‹ã‚Š${remaining}ãƒãƒ¼ãƒ )`],
            [`åä½œè¯·æ±‚è¿›è¡Œä¸­ï¼š${crossDeptName}ï¼ˆ${index + 1}/${deptIds.length}ï¼Œé˜Ÿåˆ—å‰©ä½™${remaining}ä¸ªå›¢é˜Ÿï¼‰`],
          ),
          lang,
        ),
        taskId,
      );
    }

    const coopReq = pickL(
      l(
        [
          `${crossCoordinatorName}ë‹˜, ì•ˆë…•í•˜ì„¸ìš”! ëŒ€í‘œë‹˜ ì§€ì‹œë¡œ "${taskTitle}" ì—…ë¬´ ì§„í–‰ ì¤‘ì¸ë°, ${crossDeptName} í˜‘ì¡°ê°€ í•„ìš”í•©ë‹ˆë‹¤. ë„ì›€ ë¶€íƒë“œë ¤ìš”! ğŸ¤`,
          `${crossCoordinatorName}ë‹˜! "${taskTitle}" ê±´ìœ¼ë¡œ ${crossDeptName} ì§€ì›ì´ í•„ìš”í•©ë‹ˆë‹¤. ì‹œê°„ ë˜ì‹œë©´ í˜‘ì˜ ë¶€íƒë“œë¦½ë‹ˆë‹¤.`,
        ],
        [
          `Hi ${crossCoordinatorName}! We're working on "${taskTitle}" per CEO's directive and need ${crossDeptName}'s support. Could you help? ğŸ¤`,
          `${crossCoordinatorName}, we need ${crossDeptName}'s input on "${taskTitle}". Let's sync when you have a moment.`,
        ],
        [`${crossCoordinatorName}ã•ã‚“ã€CEOæŒ‡ç¤ºã®"${taskTitle}"ã§${crossDeptName}ã®å”åŠ›ãŒå¿…è¦ã§ã™ã€‚ãŠé¡˜ã„ã—ã¾ã™ï¼ğŸ¤`],
        [`${crossCoordinatorName}ï¼ŒCEOå®‰æ’çš„"${taskTitle}"éœ€è¦${crossDeptName}é…åˆï¼Œéº»çƒ¦åè°ƒä¸€ä¸‹ï¼ğŸ¤`],
      ),
      lang,
    );
    sendAgentMessage(
      teamLeader,
      coopReq,
      "chat",
      "agent",
      crossCoordinator.id === teamLeader.id ? null : crossCoordinator.id,
      taskId,
    );

    // Broadcast delivery animation event for UI
    broadcast("cross_dept_delivery", {
      from_agent_id: teamLeader.id,
      to_agent_id: crossCoordinator.id,
      task_title: taskTitle,
    });

    // Cross-department leader acknowledges AND creates a real task
    const crossAckDelay = 1500 + Math.random() * 1000;
    setTimeout(() => {
      const crossSubAtRun = manualScoped
        ? findBestSubordinate(crossDeptId, crossLeader.id, projectCandidateAgentIds)
        : findBestSubordinate(crossDeptId, crossLeader.id);
      const manualPoolFallbackAtRun =
        manualScoped && projectCandidateAgentIds.length > 0
          ? pickManualPoolAgent(projectCandidateAgentIds, crossDeptId, [teamLeader.id]) ||
            pickManualPoolAgent(projectCandidateAgentIds, null, [teamLeader.id]) ||
            pickManualPoolAgent(projectCandidateAgentIds, crossDeptId) ||
            pickManualPoolAgent(projectCandidateAgentIds, null)
          : null;
      const execAgent =
        crossSubAtRun ??
        (crossLeaderAllowed ? crossLeader : manualPoolFallbackAtRun) ??
        crossCoordinator ??
        crossLeader;
      const execName = lang === "ko" ? execAgent.name_ko || execAgent.name : execAgent.name;

      const crossAckMsg =
        execAgent.id !== crossCoordinator.id
          ? pickL(
              l(
                [
                  `ë„¤, ${leaderName}ë‹˜! í™•ì¸í–ˆìŠµë‹ˆë‹¤. ${execName}ì—ê²Œ ë°”ë¡œ ë°°ì •í•˜ê² ìŠµë‹ˆë‹¤ ğŸ‘`,
                  `ì•Œê² ìŠµë‹ˆë‹¤! ${execName}ê°€ ì§€ì›í•˜ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤. ì§„í–‰ ìƒí™© ê³µìœ ë“œë¦´ê²Œìš”.`,
                ],
                [
                  `Sure, ${leaderName}! I'll assign ${execName} to support right away ğŸ‘`,
                  `Got it! ${execName} will handle the ${crossDeptName} side. I'll keep you posted.`,
                ],
                [`äº†è§£ã—ã¾ã—ãŸã€${leaderName}ã•ã‚“ï¼${execName}ã‚’å‰²ã‚Šå½“ã¦ã¾ã™ ğŸ‘`],
                [`å¥½çš„ï¼Œ${leaderName}ï¼å®‰æ’${execName}æ”¯æ´ ğŸ‘`],
              ),
              lang,
            )
          : pickL(
              l(
                [`ë„¤, ${leaderName}ë‹˜! í™•ì¸í–ˆìŠµë‹ˆë‹¤. ì œê°€ ì§ì ‘ ì²˜ë¦¬í•˜ê² ìŠµë‹ˆë‹¤ ğŸ‘`],
                [`Sure, ${leaderName}! I'll handle it personally ğŸ‘`],
                [`äº†è§£ã—ã¾ã—ãŸï¼ç§ãŒç›´æ¥å¯¾å¿œã—ã¾ã™ ğŸ‘`],
                [`å¥½çš„ï¼æˆ‘äº²è‡ªæ¥å¤„ç† ğŸ‘`],
              ),
              lang,
            );
      sendAgentMessage(crossCoordinator, crossAckMsg, "chat", "agent", null, taskId);

      // Create actual task in the cross-department
      const crossTaskId = randomUUID();
      const ct = nowMs();
      const crossTaskTitle = pickL(
        l([`[í˜‘ì—…] ${taskTitle}`], [`[Collaboration] ${taskTitle}`], [`[å”æ¥­] ${taskTitle}`], [`[åä½œ] ${taskTitle}`]),
        lang,
      );
      const parentTaskPath = db
        .prepare("SELECT project_id, project_path, workflow_pack_key FROM tasks WHERE id = ?")
        .get(taskId) as
        | {
            project_id: string | null;
            project_path: string | null;
            workflow_pack_key: string | null;
          }
        | undefined;
      const crossDetectedPath = parentTaskPath?.project_path ?? detectProjectPath(ceoMessage);
      const crossWorkflowPackKey = resolveWorkflowPackKeyForTask({
        db: db as any,
        sourceTaskPackKey: parentTaskPath?.workflow_pack_key,
        sourceTaskId: taskId,
        projectId: parentTaskPath?.project_id ?? null,
      });
      db.prepare(
        `
      INSERT INTO tasks (id, title, description, department_id, project_id, status, priority, task_type, workflow_pack_key, project_path, source_task_id, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, 'planned', 1, 'general', ?, ?, ?, ?, ?)
    `,
      ).run(
        crossTaskId,
        crossTaskTitle,
        `[Cross-dept from ${leaderDeptName}] ${ceoMessage}`,
        crossDeptId,
        parentTaskPath?.project_id ?? null,
        crossWorkflowPackKey,
        crossDetectedPath,
        taskId,
        ct,
        ct,
      );
      recordTaskCreationAudit({
        taskId: crossTaskId,
        taskTitle: crossTaskTitle,
        taskStatus: "planned",
        departmentId: crossDeptId,
        sourceTaskId: taskId,
        taskType: "general",
        projectPath: crossDetectedPath ?? null,
        trigger: "workflow.cross_dept_cooperation",
        triggerDetail: `from_dept=${leaderDeptId}; to_dept=${crossDeptId}`,
        actorType: "agent",
        actorId: crossCoordinator.id,
        actorName: crossCoordinator.name,
        body: {
          parent_task_id: taskId,
          ceo_message: ceoMessage,
          from_department_id: leaderDeptId,
          to_department_id: crossDeptId,
        },
      });
      if (parentTaskPath?.project_id) {
        db.prepare("UPDATE projects SET last_used_at = ?, updated_at = ? WHERE id = ?").run(
          ct,
          ct,
          parentTaskPath.project_id,
        );
      }
      appendTaskLog(crossTaskId, "system", `Cross-dept request from ${leaderName} (${leaderDeptName})`);
      broadcast("task_update", db.prepare("SELECT * FROM tasks WHERE id = ?").get(crossTaskId));
      const linkedSubtaskId = linkCrossDeptTaskToParentSubtask(taskId, crossDeptId, crossTaskId);
      if (linkedSubtaskId) {
        delegatedTaskToSubtask.set(crossTaskId, linkedSubtaskId);
      }

      // Delegate to cross-dept subordinate and spawn CLI
      const ct2 = nowMs();
      db.prepare(
        "UPDATE tasks SET assigned_agent_id = ?, status = 'in_progress', started_at = ?, updated_at = ? WHERE id = ?",
      ).run(execAgent.id, ct2, ct2, crossTaskId);
      db.prepare("UPDATE agents SET status = 'working', current_task_id = ? WHERE id = ?").run(
        crossTaskId,
        execAgent.id,
      );
      appendTaskLog(crossTaskId, "system", `${crossCoordinatorName} â†’ ${execName}`);

      broadcast("task_update", db.prepare("SELECT * FROM tasks WHERE id = ?").get(crossTaskId));
      broadcast("agent_status", db.prepare("SELECT * FROM agents WHERE id = ?").get(execAgent.id));

      // Register callback to start next department when this one finishes
      if (index + 1 < deptIds.length) {
        crossDeptNextCallbacks.set(crossTaskId, () => {
          const nextDelay = 2000 + Math.random() * 1000;
          setTimeout(() => {
            startCrossDeptCooperation(deptIds, index + 1, nextCtx, onAllDone);
          }, nextDelay);
        });
      } else if (onAllDone) {
        // Last department in the queue: continue only after this cross task completes review.
        crossDeptNextCallbacks.set(crossTaskId, () => {
          const nextDelay = 1200 + Math.random() * 800;
          setTimeout(() => onAllDone(), nextDelay);
        });
      }

      // Actually spawn the CLI agent
      const execProvider = execAgent.cli_provider || "claude";
      if (["claude", "codex", "gemini", "opencode"].includes(execProvider)) {
        const crossTaskData = db.prepare("SELECT * FROM tasks WHERE id = ?").get(crossTaskId) as
          | {
              title: string;
              description: string | null;
              project_path: string | null;
            }
          | undefined;
        if (crossTaskData) {
          const projPath = resolveProjectPath(crossTaskData);
          const logFilePath = path.join(logsDir, `${crossTaskId}.log`);
          const roleLabels: Record<string, string> = {
            team_leader: "Team Leader",
            senior: "Senior",
            junior: "Junior",
            intern: "Intern",
          };
          const roleLabel = roleLabels[execAgent.role] ?? execAgent.role;
          const deptConstraint = getDeptRoleConstraint(crossDeptId, crossDeptName);
          const deptPromptRaw = (
            db.prepare("SELECT prompt FROM departments WHERE id = ?").get(crossDeptId) as
              | { prompt?: string | null }
              | undefined
          )?.prompt;
          const deptPrompt = typeof deptPromptRaw === "string" ? deptPromptRaw.trim() : "";
          const deptPromptBlock = deptPrompt ? `[Department Shared Prompt]\n${deptPrompt}` : "";
          const crossConversationCtx = getRecentConversationContext(execAgent.id);
          const taskLang = resolveLang(crossTaskData.description ?? crossTaskData.title);
          const availableSkillsPromptBlock = buildAvailableSkillsPromptBlock(execProvider);
          const spawnPrompt = buildTaskExecutionPrompt(
            [
              availableSkillsPromptBlock,
              `[Task] ${crossTaskData.title}`,
              crossTaskData.description ? `\n${crossTaskData.description}` : "",
              crossConversationCtx,
              `\n---`,
              `Agent: ${execAgent.name} (${roleLabel}, ${crossDeptName})`,
              execAgent.personality ? `Personality: ${execAgent.personality}` : "",
              deptConstraint,
              deptPromptBlock,
              pickL(
                l(
                  ["ìœ„ ì‘ì—…ì„ ì¶©ë¶„íˆ ì™„ìˆ˜í•˜ì„¸ìš”. í•„ìš” ì‹œ ìœ„ ëŒ€í™” ë§¥ë½ì„ ì°¸ê³ í•˜ì„¸ìš”."],
                  ["Please complete the task above thoroughly. Use the conversation context above if relevant."],
                  ["ä¸Šè¨˜ã‚¿ã‚¹ã‚¯ã‚’ä¸å¯§ã«å®Œäº†ã—ã¦ãã ã•ã„ã€‚å¿…è¦ã«å¿œã˜ã¦ä¼šè©±ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚"],
                  ["è¯·å®Œæ•´åœ°å®Œæˆä¸Šè¿°ä»»åŠ¡ã€‚å¯æŒ‰éœ€å‚è€ƒä¸Šæ–¹ä¼šè¯ä¸Šä¸‹æ–‡ã€‚"],
                ),
                taskLang,
              ),
            ],
            {
              allowWarningFix: hasExplicitWarningFixRequest(crossTaskData.title, crossTaskData.description),
            },
          );
          const executionSession = ensureTaskExecutionSession(crossTaskId, execAgent.id, execProvider);
          const sessionPrompt = [
            `[Task Session] id=${executionSession.sessionId} owner=${executionSession.agentId} provider=${executionSession.provider}`,
            "Task-scoped session: keep continuity only for this collaboration task.",
            spawnPrompt,
          ].join("\n");

          appendTaskLog(crossTaskId, "system", `RUN start (agent=${execAgent.name}, provider=${execProvider})`);
          const crossModelConfig = getProviderModelConfig();
          const crossModel = execAgent.cli_model || crossModelConfig[execProvider]?.model || undefined;
          const crossReasoningLevel =
            execProvider === "codex"
              ? execAgent.cli_reasoning_level || crossModelConfig[execProvider]?.reasoningLevel || undefined
              : crossModelConfig[execProvider]?.reasoningLevel || undefined;
          const child = spawnCliAgent(
            crossTaskId,
            execProvider,
            sessionPrompt,
            projPath,
            logFilePath,
            crossModel,
            crossReasoningLevel,
          );
          child.on("close", (code: number | null) => {
            const linked = delegatedTaskToSubtask.get(crossTaskId);
            if (linked) {
              handleSubtaskDelegationComplete(crossTaskId, linked, code ?? 1);
            } else {
              handleTaskRunComplete(crossTaskId, code ?? 1);
            }
          });

          notifyCeo(
            pickL(
              l(
                [`${crossDeptName} ${execName}ê°€ '${taskTitle}' í˜‘ì—… ì‘ì—…ì„ ì‹œì‘í–ˆìŠµë‹ˆë‹¤.`],
                [`${crossDeptName} ${execName} started collaboration work for '${taskTitle}'.`],
                [`${crossDeptName}ã®${execName}ãŒã€Œ${taskTitle}ã€ã®å”æ¥­ä½œæ¥­ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚`],
                [`${crossDeptName} çš„ ${execName} å·²å¼€å§‹ã€Œ${taskTitle}ã€åä½œå·¥ä½œã€‚`],
              ),
              lang,
            ),
            crossTaskId,
          );
          startProgressTimer(crossTaskId, crossTaskData.title, crossDeptId);
        }
      }
    }, crossAckDelay);
  }

  return {
    recoverCrossDeptQueueAfterMissingCallback,
    startCrossDeptCooperation,
  };
}
